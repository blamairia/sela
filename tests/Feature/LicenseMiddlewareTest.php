<?php

namespace Tests\Feature;

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Route;
use App\Services\LicenseService;
use App\Http\Middleware\EnsureClientAuthorized;
use Illuminate\Support\Facades\DB;
use Mockery;

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;

class LicenseMiddlewareTest extends TestCase
{
    // use RefreshDatabase; // Disabled due to legacy migration errors

    protected $privateKey;

    protected function setUp(): void
    {
        parent::setUp();

        // 0. Manual Schema Setup (Isolation)
        Schema::dropIfExists('app_terminals');
        Schema::create('app_terminals', function (Blueprint $table) {
            $table->id();
            $table->string('hwid', 64)->unique();
            $table->string('name')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamp('last_seen_at')->nullable();
            $table->ipAddress('last_ip')->nullable();
            $table->timestamps();
        });

        // Mock Settings table (required by AppServiceProvider boot)
        Schema::dropIfExists('settings');
        Schema::create('settings', function (Blueprint $table) {
            $table->id();
            $table->string('key')->nullable();
            $table->text('value')->nullable();
            $table->timestamps();
        });
        

        
        // $this->withoutExceptionHandling(); // REMOVED for final verification
        
        // Disable Legacy Auth interference
        $this->withoutMiddleware([
            \App\Http\Middleware\Authenticate::class,
            \Illuminate\Auth\Middleware\Authenticate::class,
        ]);

        // 1. Setup Test Route protected by the middleware
        Route::middleware([EnsureClientAuthorized::class])->get('/api/_test/protected-api', function () {
            return 'SUCCESS_ACCESS';
        });

        // 2. Load the REAL private key to sign test licenses
        // (We assume the dev environment has this key, as generated by license_generator.php)
        $keyPath = base_path('private.key');
        if (file_exists($keyPath)) {
            $this->privateKey = file_get_contents($keyPath);
        } else {
            $this->markTestSkipped('private.key not found. Run license_generator.php first.');
        }
        
        // 3. Fake Storage to avoid messing with real folder
        Storage::fake();
    }

    /**
     * Helper to create a signed license file content
     */
    protected function createSignedLicense($hwid, $expiry)
    {
        $payload = [
            'hwid' => $hwid,
            'expiry' => $expiry,
            'max_clients' => 5,
            'generated_at' => date('Y-m-d H:i:s'),
            'type' => 'server_license'
        ];

        $jsonPayload = json_encode($payload);
        $encodedPayload = base64_encode($jsonPayload);

        openssl_sign($jsonPayload, $signature, $this->privateKey, OPENSSL_ALGO_SHA256);
        $encodedSignature = base64_encode($signature);

        $licenseData = [
            'payload' => $encodedPayload,
            'signature' => $encodedSignature
        ];

        return base64_encode(json_encode($licenseData));
    }

    /** @test */
    public function it_blocks_access_if_license_file_is_missing()
    {
        // No file in Storage
        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], ['REMOTE_ADDR' => '1.2.3.4']);
        
        $response->assertStatus(403);
        $response->assertSee('License file not found');
    }

    /** @test */
    public function it_blocks_access_if_license_file_is_corrupted()
    {
        Storage::put('server.lic', 'GARBAGE_CONTENT');

        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], ['REMOTE_ADDR' => '1.2.3.4']);
        
        $response->assertStatus(403);
        $response->assertSee('Invalid license format');
    }

    /** @test */
    public function it_blocks_access_if_license_is_expired()
    {
        // HWID matches, but date is past
        $licenseContent = $this->createSignedLicense('TEST_HWID', '2020-01-01');
        Storage::put('server.lic', $licenseContent);

        // Mock HWID to match
        $this->mock(LicenseService::class, function ($mock) {
            $mock->makePartial();
            $mock->shouldReceive('getSystemFingerprint')->andReturn('TEST_HWID');
        });

        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], ['REMOTE_ADDR' => '1.2.3.4']);

        $response->assertStatus(403);
        $response->assertSee('License expired');
    }

    /** @test */
    public function it_blocks_access_if_hwid_mismatches()
    {
        // License is for OTHER_PC
        $licenseContent = $this->createSignedLicense('OTHER_PC', '2030-01-01');
        Storage::put('server.lic', $licenseContent);

        // Machine is THIS_PC
        $this->mock(LicenseService::class, function ($mock) {
            $mock->makePartial();
            $mock->shouldReceive('getSystemFingerprint')->andReturn('THIS_PC');
        });

        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], ['REMOTE_ADDR' => '1.2.3.4']);

        $response->assertStatus(403);
        $response->assertSee('License is bound to another machine');
    }

    /** @test */
    public function it_allows_localhost_admin_access_with_valid_license()
    {
        // Valid License
        $licenseContent = $this->createSignedLicense('THIS_PC', '2030-01-01');
        Storage::put('server.lic', $licenseContent);

        $this->mock(LicenseService::class, function ($mock) {
            $mock->makePartial();
            $mock->shouldReceive('getSystemFingerprint')->andReturn('THIS_PC');
        });

        // Request from 127.0.0.1
        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], ['REMOTE_ADDR' => '127.0.0.1']);

        $response->assertStatus(200);
        $response->assertSee('SUCCESS_ACCESS');
    }

    /** @test */
    public function it_blocks_remote_client_without_header()
    {
        // Valid License
        $licenseContent = $this->createSignedLicense('THIS_PC', '2030-01-01');
        Storage::put('server.lic', $licenseContent);

        $this->mock(LicenseService::class, function ($mock) {
            $mock->makePartial();
            $mock->shouldReceive('getSystemFingerprint')->andReturn('THIS_PC');
        });

        // Request from Remote IP, No Header
        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], ['REMOTE_ADDR' => '192.168.1.50']);

        $response->assertStatus(403);
        $response->assertSee('Access Denied');
    }

    /** @test */
    public function it_blocks_remote_client_with_unauthorized_header()
    {
        // Valid License
        $licenseContent = $this->createSignedLicense('THIS_PC', '2030-01-01');
        Storage::put('server.lic', $licenseContent);

        $this->mock(LicenseService::class, function ($mock) {
            $mock->makePartial();
            $mock->shouldReceive('getSystemFingerprint')->andReturn('THIS_PC');
        });
        
        // No terminal in DB

        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], [
             'REMOTE_ADDR' => '1.2.3.4',
             'HTTP_X-Sela-HWID' => 'POS_UNKNOWN'
        ]);

        $response->assertStatus(403);
        $response->assertSee('not authorized');
    }

    /** @test */
    public function it_allows_remote_client_with_authorized_header()
    {
        // Valid License
        $licenseContent = $this->createSignedLicense('THIS_PC', '2030-01-01');
        Storage::put('server.lic', $licenseContent);

        $this->mock(LicenseService::class, function ($mock) {
            $mock->makePartial();
            $mock->shouldReceive('getSystemFingerprint')->andReturn('THIS_PC');
        });

        // Seed DB
        DB::table('app_terminals')->insert([
            'hwid' => 'POS_1',
            'name' => 'Front Desk',
            'is_active' => true,
            'created_at' => now(),
            'updated_at' => now()
        ]);

        // Request
        // Note: We need to simulate REMOTE_ADDR not being localhost. 
        // Laravel logic: $request->ip() checks REMOTE_ADDR.
        // But headers can be passed in 2nd arg of get() or check call().
        // Let's use call() to be explicit about IP.
        
        $response = $this->call('GET', '/api/_test/protected-api', [], [], [], [
            'REMOTE_ADDR' => '192.168.1.50',
            'HTTP_X-Sela-HWID' => 'POS_1' // Headers are prefixed HTTP_ in server array
        ]);

        $response->assertStatus(200);
        $response->assertSee('SUCCESS_ACCESS');
    }
}
